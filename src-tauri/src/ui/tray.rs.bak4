//! System tray management
//!
//! Handles system tray icon and menu.

use crate::clients::ClientManager;
use crate::config::ConfigManager;
use crate::mcp::manager::McpServerManager;
use crate::providers::registry::ProviderRegistry;
use tauri::{
    menu::{MenuBuilder, MenuItem, SubmenuBuilder},
    tray::TrayIconBuilder,
    App, AppHandle, Emitter, Manager, Runtime,
};
use tracing::{error, info};
use std::sync::Arc;

/// Setup system tray icon and menu
pub fn setup_tray<R: Runtime>(app: &App<R>) -> tauri::Result<()> {
    info!("Setting up system tray");

    // Build the tray menu
    let menu = build_tray_menu(app)?;

    // Load the tray icon
    // On macOS, use the 32x32.png template icon specifically designed for the tray
    // This is a monochrome icon that will render properly with icon_as_template(true)
    // The icon is embedded at compile time from the icons directory
    const TRAY_ICON: &[u8] = include_bytes!("../../icons/32x32.png");
    let icon = tauri::image::Image::from_bytes(TRAY_ICON)
        .map_err(|e| {
            error!("Failed to load embedded tray icon: {}", e);
            tauri::Error::Anyhow(anyhow::anyhow!("Failed to load tray icon: {}", e))
        })?;

    // Create the tray icon
    let _tray = TrayIconBuilder::with_id("main")
        .icon(icon)
        .menu(&menu)
        .tooltip("LocalRouter AI")
        .icon_as_template(true)
        .show_menu_on_left_click(true)
        .on_menu_event(move |app, event| {
            let id = event.id().as_ref();
            info!("Tray menu event: {}", id);

            match id {
                "toggle_server" => {
                    info!("Toggle server requested from tray");
                    let app_clone = app.clone();
                    tauri::async_runtime::spawn(async move {
                        if let Err(e) = handle_toggle_server(&app_clone).await {
                            error!("Failed to toggle server: {}", e);
                        }
                    });
                }
                "copy_url" => {
                    info!("Copy URL requested from tray");
                    let app_clone = app.clone();
                    tauri::async_runtime::spawn(async move {
                        if let Err(e) = handle_copy_url(&app_clone).await {
                            error!("Failed to copy URL: {}", e);
                        }
                    });
                }
                "open_dashboard" => {
                    if let Some(window) = app.get_webview_window("main") {
                        let _ = window.show();
                        let _ = window.set_focus();
                    }
                }
                "create_oauth_client" => {
                    info!("Create OAuth client requested from tray");
                    if let Some(window) = app.get_webview_window("main") {
                        let _ = window.show();
                        let _ = window.set_focus();
                        let _ = window.emit("navigate-to-tab", "oauth-clients");
                    }
                }
                "create_mcp_server" => {
                    info!("Create MCP server requested from tray");
                    if let Some(window) = app.get_webview_window("main") {
                        let _ = window.show();
                        let _ = window.set_focus();
                        let _ = window.emit("navigate-to-tab", "mcp-servers");
                    }
                }
                "quit" => {
                    info!("Quit requested from tray");
                    app.exit(0);
                }
                _ => {
                    if let Some(client_id) = id.strip_prefix("copy_oauth_client_") {
                        info!("Copy OAuth client ID requested: {}", client_id);
                        let app_clone = app.clone();
                        let client_id = client_id.to_string();
                        tauri::async_runtime::spawn(async move {
                            if let Err(e) = handle_copy_oauth_client(&app_clone, &client_id).await {
                                error!("Failed to copy OAuth client ID: {}", e);
                            }
                        });
                    } else if let Some(server_id) = id.strip_prefix("start_mcp_server_") {
                        info!("Start MCP server requested: {}", server_id);
                        let app_clone = app.clone();
                        let server_id = server_id.to_string();
                        tauri::async_runtime::spawn(async move {
                            if let Err(e) = handle_start_mcp_server(&app_clone, &server_id).await {
                                error!("Failed to start MCP server: {}", e);
                            }
                        });
                    } else if let Some(server_id) = id.strip_prefix("stop_mcp_server_") {
                        info!("Stop MCP server requested: {}", server_id);
                        let app_clone = app.clone();
                        let server_id = server_id.to_string();
                        tauri::async_runtime::spawn(async move {
                            if let Err(e) = handle_stop_mcp_server(&app_clone, &server_id).await {
                                error!("Failed to stop MCP server: {}", e);
                            }
                        });
                    }
                }
            }
        })
        .build(app)?;

    info!("System tray initialized successfully");
    Ok(())
}

/// Build the system tray menu
fn build_tray_menu<R: Runtime>(app: &App<R>) -> tauri::Result<tauri::menu::Menu<R>> {
    let mut menu_builder = MenuBuilder::new(app);

    // 1. Open Dashboard at the top
    menu_builder = menu_builder.text("open_dashboard", "üìä Open Dashboard");

    // Add separator
    menu_builder = menu_builder.separator();

    // 2. Clients section
    let clients_header = MenuItem::with_id(app, "clients_header", "Clients", false, None::<&str>)?;
    menu_builder = menu_builder.item(&clients_header);

    // Get client manager and build client list
    if let Some(client_manager) = app.try_state::<Arc<ClientManager>>() {
        let clients = client_manager.list_clients();
        let provider_registry = app.try_state::<Arc<ProviderRegistry>>();
        let mcp_server_manager = app.try_state::<Arc<McpServerManager>>();
        let config_manager = app.try_state::<ConfigManager>();

        if !clients.is_empty() {
            for client in clients.iter() {
                let client_name = if client.name.is_empty() {
                    format!("Client {}", &client.id[..8])
                } else {
                    client.name.clone()
                };

                let mut client_submenu = SubmenuBuilder::new(app, &client_name);

                // LLM Models section header
                let llm_header = MenuItem::with_id(app, &format!("llm_header_{}", client.id), "LLM Models", false, None::<&str>)?;
                client_submenu = client_submenu.item(&llm_header);

                // Get routing config and models
                let routing_config = &client.routing_config;
                let active_strategy = routing_config.as_ref().map(|c| c.active_strategy);
                let models = if let Some(ref registry) = provider_registry {
                    registry.get_cached_models()
                } else {
                    vec![]
                };

                if !models.is_empty() {
                    // 1. Force Model submenu
                    let force_model_text = if matches!(active_strategy, Some(crate::config::ActiveRoutingStrategy::ForceModel)) {
                        "‚úì Force model"
                    } else {
                        "Force model"
                    };
                    let mut force_model_submenu = SubmenuBuilder::new(app, force_model_text);
                    let forced_model = routing_config.as_ref().and_then(|c| c.forced_model.as_ref());

                    for model in models.iter() {
                        let model_display = format!("{} ({})", model.id, model.provider);
                        let is_forced = if let Some((provider, model_name)) = forced_model {
                            provider == &model.provider && model_name == &model.id
                        } else {
                            false
                        };
                        let display_text = if is_forced {
                            format!("‚úì {}", model_display)
                        } else {
                            model_display
                        };

                        force_model_submenu = force_model_submenu.text(
                            format!("force_model_{}_{}_{}", client.id, model.provider, model.id),
                            display_text
                        );
                    }

                    let force_model_menu = force_model_submenu.build()?;
                    client_submenu = client_submenu.item(&force_model_menu);

                    // 2. Multi Model submenu
                    let multi_model_text = if matches!(active_strategy, Some(crate::config::ActiveRoutingStrategy::AvailableModels)) {
                        "‚úì Multi model"
                    } else {
                        "Multi model"
                    };
                    let mut multi_model_submenu = SubmenuBuilder::new(app, multi_model_text);

                    // Add strategy toggle
                    let (toggle_text, toggle_id) = if matches!(active_strategy, Some(crate::config::ActiveRoutingStrategy::AvailableModels)) {
                        ("‚úì Client can choose any model", format!("disabled_strategy_{}", client.id))
                    } else {
                        ("Enable to use any selected model", format!("enable_available_models_{}", client.id))
                    };
                    multi_model_submenu = multi_model_submenu.text(toggle_id, toggle_text);
                    multi_model_submenu = multi_model_submenu.separator();

                    // Get available models selection
                    let available_models = routing_config.as_ref().map(|c| &c.available_models);

                    // Collect unique providers
                    let mut providers: Vec<String> = models.iter()
                        .map(|m| m.provider.clone())
                        .collect::<std::collections::HashSet<_>>()
                        .into_iter()
                        .collect();
                    providers.sort();

                    // Add provider options
                    if !providers.is_empty() {
                        for provider in providers.iter() {
                            let is_provider_selected = if let Some(avail) = available_models {
                                avail.all_provider_models.contains(provider)
                            } else {
                                false
                            };
                            let provider_text = if is_provider_selected {
                                format!("‚úì All {} Models", provider)
                            } else {
                                format!("All {} Models", provider)
                            };
                            multi_model_submenu = multi_model_submenu.text(
                                format!("toggle_provider_{}_{}",client.id, provider),
                                provider_text
                            );
                        }
                        multi_model_submenu = multi_model_submenu.separator();
                    }

                    // Add individual models
                    for model in models.iter() {
                        let model_display = format!("{} ({})", model.id, model.provider);
                        let is_selected = if let Some(avail) = available_models {
                            avail.individual_models.iter().any(|(p, m)| p == &model.provider && m == &model.id)
                        } else {
                            false
                        };
                        let display_text = if is_selected {
                            format!("‚úì {}", model_display)
                        } else {
                            model_display
                        };

                        multi_model_submenu = multi_model_submenu.text(
                            format!("toggle_model_{}_{}_{}", client.id, model.provider, model.id),
                            display_text
                        );
                    }

                    let multi_model_menu = multi_model_submenu.build()?;
                    client_submenu = client_submenu.item(&multi_model_menu);

                    // 3. Prioritized list
                    let prioritized_list_text = if matches!(active_strategy, Some(crate::config::ActiveRoutingStrategy::PrioritizedList)) {
                        "‚úì Prioritized list..."
                    } else {
                        "Prioritized list..."
                    };
                    client_submenu = client_submenu.text(
                        format!("prioritized_list_{}", client.id),
                        prioritized_list_text
                    );
                } else {
                    client_submenu = client_submenu.text(
                        format!("no_models_{}", client.id),
                        "No models available"
                    );
                }

                // Add separator before Allowed MCPs
                client_submenu = client_submenu.separator();

                // Allowed MCPs section header
                let mcp_header = MenuItem::with_id(app, &format!("mcp_header_{}", client.id), "Allowed MCPs", false, None::<&str>)?;
                client_submenu = client_submenu.item(&mcp_header);

                // Get MCP servers this client can access
                if let Some(ref mcp_manager) = mcp_server_manager {
                    let all_mcp_servers = mcp_manager.list_configs();

                    // Show allowed MCP servers
                    for server_id in client.allowed_mcp_servers.iter() {
                        if let Some(server) = all_mcp_servers.iter().find(|s| &s.id == server_id) {
                            let server_name = if server.name.is_empty() {
                                format!("MCP {}", &server.id[..8])
                            } else {
                                server.name.clone()
                            };

                            let mut mcp_submenu = SubmenuBuilder::new(app, &server_name);

                            // Get server URL and port
                            let port = if let Some(ref cfg_mgr) = config_manager {
                                cfg_mgr.get().server.port
                            } else {
                                3625
                            };

                            mcp_submenu = mcp_submenu
                                .text(format!("copy_mcp_url_{}_{}", client.id, server.id), "üìã Copy URL");

                            mcp_submenu = mcp_submenu
                                .text(format!("copy_mcp_bearer_{}_{}", client.id, server.id), "üìã Copy Bearer token");

                            let mcp_menu = mcp_submenu.build()?;
                            client_submenu = client_submenu.item(&mcp_menu);
                        }
                    }
                }

                // Add "+ Add MCP..." option
                client_submenu = client_submenu.text(
                    format!("add_mcp_{}", client.id),
                    "‚ûï Add MCP..."
                );

                let client_menu = client_submenu.build()?;
                menu_builder = menu_builder.item(&client_menu);
            }
        }
    }

    // Add "+ Create & copy API Key" button
    menu_builder = menu_builder.text("create_and_copy_api_key", "‚ûï Create & copy API Key");

    // Add separator before Server section
    menu_builder = menu_builder.separator();

    // Get port and server status
    let (host, port, server_text) = if let Some(config_manager) = app.try_state::<ConfigManager>() {
        let config = config_manager.get();
        let status = if let Some(server_manager) = app.try_state::<Arc<crate::server::ServerManager>>() {
            match server_manager.get_status() {
                crate::server::ServerStatus::Running => "‚èπÔ∏è Stop Server",
                crate::server::ServerStatus::Stopped => "‚ñ∂Ô∏è Start Server",
            }
        } else {
            "‚ñ∂Ô∏è Start Server"
        };
        (config.server.host.clone(), config.server.port, status)
    } else {
        ("127.0.0.1".to_string(), 3625, "‚ñ∂Ô∏è Start Server")
    };

    // Add Server section header with IP:Port
    let server_header = MenuItem::with_id(
        app,
        "server_header",
        format!("Server {}:{}", host, port),
        false,
        None::<&str>
    )?;
    menu_builder = menu_builder.item(&server_header);

    // Add server-related items
    menu_builder = menu_builder
        .text("copy_url", "üìã Copy URL")
        .text("toggle_server", server_text);

    // Add separator before quit
    menu_builder = menu_builder.separator();

    // Add quit option
    menu_builder = menu_builder.text("quit", "‚ùå Shut down");

    menu_builder.build()
}

/// Rebuild the system tray menu with updated API keys
pub fn rebuild_tray_menu<R: Runtime>(app: &AppHandle<R>) -> tauri::Result<()> {
    info!("Rebuilding system tray menu");

    let menu = build_tray_menu_from_handle(app)?;

    if let Some(tray) = app.tray_by_id("main") {
        tray.set_menu(Some(menu))?;
        info!("System tray menu updated");
    }

    Ok(())
}

/// Build tray menu from AppHandle (used for rebuilding)
fn build_tray_menu_from_handle<R: Runtime>(app: &AppHandle<R>) -> tauri::Result<tauri::menu::Menu<R>> {
    let mut menu_builder = MenuBuilder::new(app);

    // 1. Open Dashboard at the top
    menu_builder = menu_builder.text("open_dashboard", "üìä Open Dashboard");

    // Add separator
    menu_builder = menu_builder.separator();

    // 2. Clients section
    let clients_header = MenuItem::with_id(app, "clients_header", "Clients", false, None::<&str>)?;
    menu_builder = menu_builder.item(&clients_header);

    // Get client manager and build client list
    if let Some(client_manager) = app.try_state::<Arc<ClientManager>>() {
        let clients = client_manager.list_clients();
        let provider_registry = app.try_state::<Arc<ProviderRegistry>>();
        let mcp_server_manager = app.try_state::<Arc<McpServerManager>>();
        let config_manager = app.try_state::<ConfigManager>();

        if !clients.is_empty() {
            for client in clients.iter() {
                let client_name = if client.name.is_empty() {
                    format!("Client {}", &client.id[..8])
                } else {
                    client.name.clone()
                };

                let mut client_submenu = SubmenuBuilder::new(app, &client_name);

                // LLM Models section header
                let llm_header = MenuItem::with_id(app, &format!("llm_header_{}", client.id), "LLM Models", false, None::<&str>)?;
                client_submenu = client_submenu.item(&llm_header);

                // Get routing config and models
                let routing_config = &client.routing_config;
                let active_strategy = routing_config.as_ref().map(|c| c.active_strategy);
                let models = if let Some(ref registry) = provider_registry {
                    registry.get_cached_models()
                } else {
                    vec![]
                };

                if !models.is_empty() {
                    // 1. Force Model submenu
                    let force_model_text = if matches!(active_strategy, Some(crate::config::ActiveRoutingStrategy::ForceModel)) {
                        "‚úì Force model"
                    } else {
                        "Force model"
                    };
                    let mut force_model_submenu = SubmenuBuilder::new(app, force_model_text);
                    let forced_model = routing_config.as_ref().and_then(|c| c.forced_model.as_ref());

                    for model in models.iter() {
                        let model_display = format!("{} ({})", model.id, model.provider);
                        let is_forced = if let Some((provider, model_name)) = forced_model {
                            provider == &model.provider && model_name == &model.id
                        } else {
                            false
                        };
                        let display_text = if is_forced {
                            format!("‚úì {}", model_display)
                        } else {
                            model_display
                        };

                        force_model_submenu = force_model_submenu.text(
                            format!("force_model_{}_{}_{}", client.id, model.provider, model.id),
                            display_text
                        );
                    }

                    let force_model_menu = force_model_submenu.build()?;
                    client_submenu = client_submenu.item(&force_model_menu);

                    // 2. Multi Model submenu
                    let multi_model_text = if matches!(active_strategy, Some(crate::config::ActiveRoutingStrategy::AvailableModels)) {
                        "‚úì Multi model"
                    } else {
                        "Multi model"
                    };
                    let mut multi_model_submenu = SubmenuBuilder::new(app, multi_model_text);

                    // Add strategy toggle
                    let (toggle_text, toggle_id) = if matches!(active_strategy, Some(crate::config::ActiveRoutingStrategy::AvailableModels)) {
                        ("‚úì Client can choose any model", format!("disabled_strategy_{}", client.id))
                    } else {
                        ("Enable to use any selected model", format!("enable_available_models_{}", client.id))
                    };
                    multi_model_submenu = multi_model_submenu.text(toggle_id, toggle_text);
                    multi_model_submenu = multi_model_submenu.separator();

                    // Get available models selection
                    let available_models = routing_config.as_ref().map(|c| &c.available_models);

                    // Collect unique providers
                    let mut providers: Vec<String> = models.iter()
                        .map(|m| m.provider.clone())
                        .collect::<std::collections::HashSet<_>>()
                        .into_iter()
                        .collect();
                    providers.sort();

                    // Add provider options
                    if !providers.is_empty() {
                        for provider in providers.iter() {
                            let is_provider_selected = if let Some(avail) = available_models {
                                avail.all_provider_models.contains(provider)
                            } else {
                                false
                            };
                            let provider_text = if is_provider_selected {
                                format!("‚úì All {} Models", provider)
                            } else {
                                format!("All {} Models", provider)
                            };
                            multi_model_submenu = multi_model_submenu.text(
                                format!("toggle_provider_{}_{}",client.id, provider),
                                provider_text
                            );
                        }
                        multi_model_submenu = multi_model_submenu.separator();
                    }

                    // Add individual models
                    for model in models.iter() {
                        let model_display = format!("{} ({})", model.id, model.provider);
                        let is_selected = if let Some(avail) = available_models {
                            avail.individual_models.iter().any(|(p, m)| p == &model.provider && m == &model.id)
                        } else {
                            false
                        };
                        let display_text = if is_selected {
                            format!("‚úì {}", model_display)
                        } else {
                            model_display
                        };

                        multi_model_submenu = multi_model_submenu.text(
                            format!("toggle_model_{}_{}_{}", client.id, model.provider, model.id),
                            display_text
                        );
                    }

                    let multi_model_menu = multi_model_submenu.build()?;
                    client_submenu = client_submenu.item(&multi_model_menu);

                    // 3. Prioritized list
                    let prioritized_list_text = if matches!(active_strategy, Some(crate::config::ActiveRoutingStrategy::PrioritizedList)) {
                        "‚úì Prioritized list..."
                    } else {
                        "Prioritized list..."
                    };
                    client_submenu = client_submenu.text(
                        format!("prioritized_list_{}", client.id),
                        prioritized_list_text
                    );
                } else {
                    client_submenu = client_submenu.text(
                        format!("no_models_{}", client.id),
                        "No models available"
                    );
                }

                // Add separator before Allowed MCPs
                client_submenu = client_submenu.separator();

                // Allowed MCPs section header
                let mcp_header = MenuItem::with_id(app, &format!("mcp_header_{}", client.id), "Allowed MCPs", false, None::<&str>)?;
                client_submenu = client_submenu.item(&mcp_header);

                // Get MCP servers this client can access
                if let Some(ref mcp_manager) = mcp_server_manager {
                    let all_mcp_servers = mcp_manager.list_configs();

                    // Show allowed MCP servers
                    for server_id in client.allowed_mcp_servers.iter() {
                        if let Some(server) = all_mcp_servers.iter().find(|s| &s.id == server_id) {
                            let server_name = if server.name.is_empty() {
                                format!("MCP {}", &server.id[..8])
                            } else {
                                server.name.clone()
                            };

                            let mut mcp_submenu = SubmenuBuilder::new(app, &server_name);

                            mcp_submenu = mcp_submenu
                                .text(format!("copy_mcp_url_{}_{}", client.id, server.id), "üìã Copy URL");

                            mcp_submenu = mcp_submenu
                                .text(format!("copy_mcp_bearer_{}_{}", client.id, server.id), "üìã Copy Bearer token");

                            let mcp_menu = mcp_submenu.build()?;
                            client_submenu = client_submenu.item(&mcp_menu);
                        }
                    }
                }

                // Add "+ Add MCP..." option
                client_submenu = client_submenu.text(
                    format!("add_mcp_{}", client.id),
                    "‚ûï Add MCP..."
                );

                let client_menu = client_submenu.build()?;
                menu_builder = menu_builder.item(&client_menu);
            }
        }
    }

    // Add "+ Create & copy API Key" button
    menu_builder = menu_builder.text("create_and_copy_api_key", "‚ûï Create & copy API Key");

    // Add separator before Server section
    menu_builder = menu_builder.separator();

    // Get port and server status
    let (host, port, server_text) = if let Some(config_manager) = app.try_state::<ConfigManager>() {
        let config = config_manager.get();
        let status = if let Some(server_manager) = app.try_state::<Arc<crate::server::ServerManager>>() {
            match server_manager.get_status() {
                crate::server::ServerStatus::Running => "‚èπÔ∏è Stop Server",
                crate::server::ServerStatus::Stopped => "‚ñ∂Ô∏è Start Server",
            }
        } else {
            "‚ñ∂Ô∏è Start Server"
        };
        (config.server.host.clone(), config.server.port, status)
    } else {
        ("127.0.0.1".to_string(), 3625, "‚ñ∂Ô∏è Start Server")
    };

    // Add Server section header with IP:Port
    let server_header = MenuItem::with_id(
        app,
        "server_header",
        format!("Server {}:{}", host, port),
        false,
        None::<&str>
    )?;
    menu_builder = menu_builder.item(&server_header);

    // Add server-related items
    menu_builder = menu_builder
        .text("copy_url", "üìã Copy URL")
        .text("toggle_server", server_text);

    // Add separator before quit
    menu_builder = menu_builder.separator();

    // Add quit option
    menu_builder = menu_builder.text("quit", "‚ùå Shut down");

    menu_builder.build()
}

/// Handle copying the server URL to clipboard
async fn handle_copy_url<R: Runtime>(app: &AppHandle<R>) -> tauri::Result<()> {
    let config_manager = app.state::<ConfigManager>();
    let config = config_manager.get();

    let url = format!("http://{}:{}", config.server.host, config.server.port);

    if let Err(e) = copy_to_clipboard(&url) {
        error!("Failed to copy URL to clipboard: {}", e);
        return Err(tauri::Error::Anyhow(e));
    }

    info!("Server URL copied to clipboard: {}", url);

    Ok(())
}

/// Handle toggling the server on/off
async fn handle_toggle_server<R: Runtime>(app: &AppHandle<R>) -> tauri::Result<()> {
    let server_manager = app.state::<Arc<crate::server::ServerManager>>();

    let status = server_manager.get_status();
    match status {
        crate::server::ServerStatus::Running => {
            info!("Stopping server from tray");
            server_manager.stop().await;
            let _ = app.emit("server-status-changed", "stopped");
        }
        crate::server::ServerStatus::Stopped => {
            info!("Starting server from tray");

            // Get dependencies
            let config_manager = app.state::<ConfigManager>();
            let router = app.state::<Arc<crate::router::Router>>();
            let mcp_server_manager = app.state::<Arc<crate::mcp::McpServerManager>>();
            let rate_limiter = app.state::<Arc<crate::router::RateLimiterManager>>();
            let provider_registry = app.state::<Arc<ProviderRegistry>>();
            let client_manager = app.state::<Arc<crate::clients::ClientManager>>();
            let token_store = app.state::<Arc<crate::clients::TokenStore>>();

            // Get server config
            let server_config = {
                let config = config_manager.get();
                crate::server::ServerConfig {
                    host: config.server.host.clone(),
                    port: config.server.port,
                    enable_cors: config.server.enable_cors,
                }
            };

            // Start the server
            server_manager
                .start(
                    server_config,
                    crate::server::manager::ServerDependencies {
                        router: router.inner().clone(),
                        mcp_server_manager: mcp_server_manager.inner().clone(),
                        rate_limiter: rate_limiter.inner().clone(),
                        provider_registry: provider_registry.inner().clone(),
                        config_manager: Arc::new((*config_manager).clone()),
                        client_manager: client_manager.inner().clone(),
                        token_store: token_store.inner().clone(),
                    },
                )
                .await
                .map_err(tauri::Error::Anyhow)?;

            let _ = app.emit("server-status-changed", "running");
        }
    }

    // Rebuild tray menu to update button text
    rebuild_tray_menu(app)?;

    Ok(())
}
// /// Handle generating a new API key from the system tray
// async fn handle_generate_key_from_tray<R: Runtime>(app: &AppHandle<R>) -> tauri::Result<()> {
//     info!("Generating new API key from tray");
// 
    // Get managers from state
//         let key_manager = app.state::<ApiKeyManager>();
//     let config_manager = app.state::<ConfigManager>();
// 
    // Create key with "All" model selection
//     let (key_value, config) = key_manager
//         .create_key(None)
//         .await
//         .map_err(|e| tauri::Error::Anyhow(e.into()))?;
// 
    // Set model selection to "All"
//     let _ = key_manager.update_key(&config.id, |cfg| {
//         cfg.model_selection = Some(ModelSelection::All);
//     });
// 
    // Save to config
//     config_manager
//         .update(|cfg| {
            // Find and update the key in the config
//             if let Some(key) = cfg.api_keys.iter_mut().find(|k| k.id == config.id) {
//                 key.model_selection = Some(ModelSelection::All);
//             } else {
                // Key not found, add it
//                 let mut new_config = config.clone();
//                 new_config.model_selection = Some(ModelSelection::All);
//                 cfg.api_keys.push(new_config);
//             }
//         })
//         .map_err(|e| tauri::Error::Anyhow(e.into()))?;
// 
//     config_manager
//         .save()
//         .await
//         .map_err(|e| tauri::Error::Anyhow(e.into()))?;
// 
    // Copy to clipboard
//     if let Err(e) = copy_to_clipboard(&key_value) {
//         error!("Failed to copy to clipboard: {}", e);
//     }
// 
    // Rebuild tray menu
//     rebuild_tray_menu(app)?;
// 
//     info!("API key generated and copied to clipboard: {}", config.name);
// 
//     Ok(())
// }
// /// Handle copying an API key to clipboard
// async fn handle_copy_key<R: Runtime>(app: &AppHandle<R>, key_id: &str) -> tauri::Result<()> {
//         let key_manager = app.state::<ApiKeyManager>();
// 
//     let key_value = key_manager
//         .get_key_value(key_id)
//         .map_err(|e| tauri::Error::Anyhow(e.into()))?
//         .ok_or_else(|| tauri::Error::Anyhow(anyhow::anyhow!("API key not found in keychain")))?;
// 
//     if let Err(e) = copy_to_clipboard(&key_value) {
//         error!("Failed to copy to clipboard: {}", e);
//         return Err(tauri::Error::Anyhow(e));
//     }
// 
//     info!("API key copied to clipboard: {}", key_id);
// 
//     Ok(())
// }
// /// Handle toggling an API key's enabled state
// async fn handle_toggle_key<R: Runtime>(app: &AppHandle<R>, key_id: &str) -> tauri::Result<()> {
//         let key_manager = app.state::<ApiKeyManager>();
//     let config_manager = app.state::<ConfigManager>();
// 
    // Get current state
//     let key = key_manager
//         .get_key(key_id)
//         .ok_or_else(|| tauri::Error::Anyhow(anyhow::anyhow!("API key not found")))?;
// 
//     let new_enabled = !key.enabled;
// 
    // Update in key manager
//     key_manager
//         .update_key(key_id, |cfg| {
//             cfg.enabled = new_enabled;
//         })
//         .map_err(|e| tauri::Error::Anyhow(e.into()))?;
// 
    // Update in config
//     config_manager
//         .update(|cfg| {
//             if let Some(k) = cfg.api_keys.iter_mut().find(|k| k.id == key_id) {
//                 k.enabled = new_enabled;
//             }
//         })
//         .map_err(|e| tauri::Error::Anyhow(e.into()))?;
// 
//     config_manager
//         .save()
//         .await
//         .map_err(|e| tauri::Error::Anyhow(e.into()))?;
// 
    // Rebuild tray menu
//     rebuild_tray_menu(app)?;
// 
//     info!("API key {} {}", key_id, if new_enabled { "enabled" } else { "disabled" });
// 
//     Ok(())
// }

/// Handle setting a specific model for an API key
///
/// Supports toggling between different model selection types:
/// - "all" - Set to ModelSelection::All
/// - "provider_{name}" - Toggle all models from a provider
/// - "model_{provider}_{model}" - Toggle a specific model
// async fn handle_set_model<R: Runtime>(app: &AppHandle<R>, key_id: &str, model_spec: &str) -> tauri::Result<()> {
//         let key_manager = app.state::<ApiKeyManager>();
//     let config_manager = app.state::<ConfigManager>();
// 
//     info!("Setting model {} for key {}", model_spec, key_id);
// 
    // Get current key configuration
//     let current_key = key_manager
//         .get_key(key_id)
//         .ok_or_else(|| tauri::Error::Anyhow(anyhow::anyhow!("API key not found")))?;
// 
//     let new_selection = if model_spec == "all" {
        // Set to "All Models"
//         ModelSelection::All
//     } else if let Some(provider) = model_spec.strip_prefix("provider_") {
        // Toggle provider in Custom selection
//         match &current_key.model_selection {
//             Some(ModelSelection::Custom { all_provider_models, individual_models }) => {
//                 let mut new_providers = all_provider_models.clone();
//                 let new_individual = individual_models.clone();
// 
                // Toggle: if provider is already selected, remove it; otherwise add it
//                 if let Some(pos) = new_providers.iter().position(|p| p == provider) {
//                     new_providers.remove(pos);
//                 } else {
//                     new_providers.push(provider.to_string());
//                 }
// 
//                 ModelSelection::Custom {
//                     all_provider_models: new_providers,
//                     individual_models: new_individual,
//                 }
//             }
//             _ => {
                // If not Custom, create new Custom with just this provider
//                 ModelSelection::Custom {
//                     all_provider_models: vec![provider.to_string()],
//                     individual_models: vec![],
//                 }
//             }
//         }
//     } else if let Some(rest) = model_spec.strip_prefix("model_") {
        // Toggle individual model in Custom selection
        // Format: model_{provider}_{model}
//         if let Some((provider, model)) = rest.split_once('_') {
//             match &current_key.model_selection {
//                 Some(ModelSelection::Custom { all_provider_models, individual_models }) => {
//                     let new_providers = all_provider_models.clone();
//                     let mut new_individual = individual_models.clone();
// 
                    // Toggle: if model is already selected, remove it; otherwise add it
//                     let model_tuple = (provider.to_string(), model.to_string());
//                     if let Some(pos) = new_individual.iter().position(|m| m == &model_tuple) {
//                         new_individual.remove(pos);
//                     } else {
//                         new_individual.push(model_tuple);
//                     }
// 
//                     ModelSelection::Custom {
//                         all_provider_models: new_providers,
//                         individual_models: new_individual,
//                     }
//                 }
//                 _ => {
                    // If not Custom, create new Custom with just this model
//                     ModelSelection::Custom {
//                         all_provider_models: vec![],
//                         individual_models: vec![(provider.to_string(), model.to_string())],
//                     }
//                 }
//             }
//         } else {
//             return Err(tauri::Error::Anyhow(anyhow::anyhow!("Invalid model spec format")));
//         }
//     } else {
//         return Err(tauri::Error::Anyhow(anyhow::anyhow!("Unknown model spec format")));
//     };
// 
    // Update in key manager
//     key_manager
//         .update_key(key_id, |cfg| {
//             cfg.model_selection = Some(new_selection.clone());
//         })
//         .map_err(|e| tauri::Error::Anyhow(e.into()))?;
// 
    // Update in config
//     config_manager
//         .update(|cfg| {
//             if let Some(k) = cfg.api_keys.iter_mut().find(|k| k.id == key_id) {
//                 k.model_selection = Some(new_selection);
//             }
//         })
//         .map_err(|e| tauri::Error::Anyhow(e.into()))?;
// 
    // Save to disk
//     config_manager
//         .save()
//         .await
//         .map_err(|e| tauri::Error::Anyhow(e.into()))?;
// 
    // Rebuild tray menu to show updated checkmarks
//     rebuild_tray_menu(app)?;
// 
//     info!("Model selection updated for key {}", key_id);
// 
//     Ok(())
// }
#[allow(dead_code)]
async fn handle_prioritized_list<R: Runtime>(
    app: &AppHandle<R>,
    key_id: &str,
) -> tauri::Result<()> {
    info!("Opening prioritized list for key {}", key_id);

    // Open the dashboard window
    if let Some(window) = app.get_webview_window("main") {
        let _ = window.show();
        let _ = window.set_focus();

        // Emit event to open the prioritized list modal for this key
        let _ = app.emit("open-prioritized-list", key_id);
    }

    Ok(())
}

/// Update the tray icon based on server status
pub fn update_tray_icon<R: Runtime>(app: &AppHandle<R>, status: &str) -> tauri::Result<()> {
    // Embed the tray icons at compile time
    const TRAY_ICON: &[u8] = include_bytes!("../../icons/32x32.png");
    const TRAY_ICON_ACTIVE: &[u8] = include_bytes!("../../icons/32x32-active.png");

    if let Some(tray) = app.tray_by_id("main") {
        match status {
            "stopped" => {
                // Stopped: Use template icon in template mode (monochrome/dimmed)
                let icon = tauri::image::Image::from_bytes(TRAY_ICON)
                    .map_err(|e| tauri::Error::Anyhow(anyhow::anyhow!("Failed to load tray icon: {}", e)))?;
                tray.set_icon(Some(icon))?;
                tray.set_icon_as_template(true)?;
                tray.set_tooltip(Some("LocalRouter AI - Server Stopped"))?;
                info!("Tray icon updated: stopped (template mode)");
            }
            "running" => {
                // Running: Use template icon in template mode (monochrome)
                let icon = tauri::image::Image::from_bytes(TRAY_ICON)
                    .map_err(|e| tauri::Error::Anyhow(anyhow::anyhow!("Failed to load tray icon: {}", e)))?;
                tray.set_icon(Some(icon))?;
                tray.set_icon_as_template(true)?;
                tray.set_tooltip(Some("LocalRouter AI - Server Running"))?;
                info!("Tray icon updated: running (template mode)");
            }
            "active" => {
                // Active: Use active icon in non-template mode to show activity
                let icon = tauri::image::Image::from_bytes(TRAY_ICON_ACTIVE)
                    .map_err(|e| tauri::Error::Anyhow(anyhow::anyhow!("Failed to load active tray icon: {}", e)))?;
                tray.set_icon(Some(icon))?;
                tray.set_icon_as_template(false)?;
                tray.set_tooltip(Some("LocalRouter AI - Processing Request"))?;
                info!("Tray icon updated: active (full color)");

                // Schedule a return to "running" state after 2 seconds
                let app_clone = app.clone();
                tauri::async_runtime::spawn(async move {
                    tokio::time::sleep(tokio::time::Duration::from_secs(2)).await;
                    if let Err(e) = update_tray_icon(&app_clone, "running") {
                        error!("Failed to reset tray icon to running: {}", e);
                    }
                });
            }
            _ => {
                error!("Unknown tray icon status: {}", status);
            }
        }
    }

    Ok(())
}

/// Copy text to clipboard
fn copy_to_clipboard(text: &str) -> Result<(), anyhow::Error> {
    let mut clipboard = arboard::Clipboard::new()
        .map_err(|e| anyhow::anyhow!("Failed to access clipboard: {}", e))?;

    clipboard
        .set_text(text)
        .map_err(|e| anyhow::anyhow!("Failed to set clipboard text: {}", e))?;

    Ok(())
}

/// Handle copying OAuth client ID from the system tray
async fn handle_copy_oauth_client<R: Runtime>(app: &AppHandle<R>, client_id: &str) -> tauri::Result<()> {
    info!("Copying OAuth client ID: {}", client_id);

    // Get OAuth client manager from state
    let oauth_client_manager = app.try_state::<OAuthClientManager>()
        .ok_or_else(|| anyhow::anyhow!("OAuth client manager not found"))?;

    // Get the client
    let client = oauth_client_manager.get_client(client_id)
        .ok_or_else(|| anyhow::anyhow!("OAuth client not found"))?;

    // Copy client_id to clipboard
    copy_to_clipboard(&client.client_id)?;

    info!("OAuth client ID copied to clipboard");
    Ok(())
}

/// Handle starting an MCP server from the system tray
async fn handle_start_mcp_server<R: Runtime>(app: &AppHandle<R>, server_id: &str) -> tauri::Result<()> {
    info!("Starting MCP server: {}", server_id);

    // Get MCP server manager from state
    let mcp_server_manager = app.try_state::<Arc<McpServerManager>>()
        .ok_or_else(|| anyhow::anyhow!("MCP server manager not found"))?;

    // Start the server
    mcp_server_manager.start_server(server_id).await
        .map_err(|e| anyhow::anyhow!("Failed to start MCP server: {}", e))?;

    // Rebuild tray menu to update status
    rebuild_tray_menu(app)?;

    info!("MCP server started successfully");
    Ok(())
}

/// Handle stopping an MCP server from the system tray
async fn handle_stop_mcp_server<R: Runtime>(app: &AppHandle<R>, server_id: &str) -> tauri::Result<()> {
    info!("Stopping MCP server: {}", server_id);

    // Get MCP server manager from state
    let mcp_server_manager = app.try_state::<Arc<McpServerManager>>()
        .ok_or_else(|| anyhow::anyhow!("MCP server manager not found"))?;

    // Stop the server
    mcp_server_manager.stop_server(server_id).await
        .map_err(|e| anyhow::anyhow!("Failed to stop MCP server: {}", e))?;

    // Rebuild tray menu to update status
    rebuild_tray_menu(app)?;

    info!("MCP server stopped successfully");
    Ok(())
}
