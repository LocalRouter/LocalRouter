// Build-time code generator for catalog
//
// Generates Rust source code with embedded static model data

use crate::build::models::OpenRouterModel;
use std::fs;
use std::time::{SystemTime, UNIX_EPOCH};

const OUTPUT_FILE: &str = "catalog/catalog.rs";

pub struct CatalogCodeGenerator {
    output_path: String,
}

impl CatalogCodeGenerator {
    pub fn new() -> Self {
        Self {
            output_path: OUTPUT_FILE.to_string(),
        }
    }

    /// Generate complete catalog.rs file
    pub fn generate(&self, models: &[OpenRouterModel]) -> Result<(), Box<dyn std::error::Error>> {
        let mut code = String::new();

        // File header
        code.push_str(&self.generate_header());

        // Imports
        code.push_str(&self.generate_imports());

        // Metadata
        code.push_str(&self.generate_metadata(models.len()));

        // Model array
        code.push_str(&self.generate_models_array(models));

        // Write to file
        fs::write(&self.output_path, code)?;

        println!("cargo:warning=Generated catalog.rs with {} models ({} bytes)",
            models.len(),
            fs::metadata(&self.output_path)?.len()
        );

        Ok(())
    }

    fn generate_header(&self) -> String {
        format!(
            "// Auto-generated model catalog - DO NOT EDIT MANUALLY\n\
             //\n\
             // This file is generated by build.rs from OpenRouter API data.\n\
             // To regenerate: LOCALROUTER_REBUILD_CATALOG=1 cargo build\n\
             //\n\
             // Generated at: {}\n\
             // Privacy: All data embedded at build time, no runtime network requests\n\n",
            chrono::Utc::now().to_rfc3339()
        )
    }

    fn generate_imports(&self) -> String {
        "use crate::catalog::types::{CatalogMetadata, CatalogModel, CatalogPricing, Modality};\n\
         use chrono::{DateTime, Utc};\n\n".to_string()
    }

    fn generate_metadata(&self, total_models: usize) -> String {
        let now_secs = SystemTime::now()
            .duration_since(UNIX_EPOCH)
            .unwrap()
            .as_secs();

        format!(
            "pub static CATALOG_METADATA: CatalogMetadata = CatalogMetadata {{\n\
             \x20   fetch_timestamp: {},\n\
             \x20   api_version: \"v1\",\n\
             \x20   total_models: {},\n\
             }};\n\n",
            now_secs, total_models
        )
    }

    fn generate_models_array(&self, models: &[OpenRouterModel]) -> String {
        let mut code = String::from("pub static CATALOG_MODELS: &[CatalogModel] = &[\n");

        for model in models {
            code.push_str(&self.generate_model_entry(model));
        }

        code.push_str("];\n");
        code
    }

    fn generate_model_entry(&self, model: &OpenRouterModel) -> String {
        let aliases = self.generate_aliases(model);
        let modality = self.map_modality(model.modality());
        let supported_params = self.generate_string_array(&model.supported_parameters);

        format!(
            "    CatalogModel {{\n\
             \x20       id: \"{}\",\n\
             \x20       aliases: &[{}],\n\
             \x20       name: \"{}\",\n\
             \x20       created: {},\n\
             \x20       context_length: {},\n\
             \x20       modality: {},\n\
             \x20       pricing: CatalogPricing {{\n\
             \x20           prompt_per_token: {},\n\
             \x20           completion_per_token: {},\n\
             \x20           image_per_token: {},\n\
             \x20           request_cost: {},\n\
             \x20           currency: \"USD\",\n\
             \x20       }},\n\
             \x20       supported_parameters: &[{}],\n\
             \x20   }},\n",
            self.escape_string(&model.id),
            aliases,
            self.escape_string(&model.name),
            model.created,
            model.context_length,
            modality,
            model.prompt_cost_per_token(),
            model.completion_cost_per_token(),
            model.image_cost_per_token()
                .map(|v| format!("Some({})", v))
                .unwrap_or_else(|| "None".to_string()),
            model.request_cost()
                .map(|v| format!("Some({})", v))
                .unwrap_or_else(|| "None".to_string()),
            supported_params
        )
    }

    fn generate_aliases(&self, model: &OpenRouterModel) -> String {
        let mut aliases = Vec::new();

        // Extract base name: "openai/gpt-4" → "gpt-4"
        if let Some((provider, base)) = model.id.split_once('/') {
            aliases.push(base.to_string());

            // Add provider-specific common variations
            match (provider, base) {
                ("openai", name) if name.starts_with("gpt-") => {
                    // gpt-4 → gpt4
                    let compact = name.replace("-", "");
                    if compact != name {
                        aliases.push(compact);
                    }
                }
                ("anthropic", name) if name.contains("claude") => {
                    // claude-opus-4-20250514 → claude-opus-4, opus-4
                    if let Some(short) = name.split('-').take(3).collect::<Vec<_>>().get(0..3) {
                        aliases.push(short.join("-"));
                    }
                    if name.contains("opus") {
                        aliases.push("opus".to_string());
                    } else if name.contains("sonnet") {
                        aliases.push("sonnet".to_string());
                    } else if name.contains("haiku") {
                        aliases.push("haiku".to_string());
                    }
                }
                ("google", name) if name.contains("gemini") => {
                    // gemini-2.0-flash-exp → gemini-2, gemini-flash
                    if let Some(version) = name.strip_prefix("gemini-") {
                        if let Some((ver_num, _)) = version.split_once('-') {
                            aliases.push(format!("gemini-{}", ver_num));
                        }
                    }
                }
                ("meta-llama", name) => {
                    // meta-llama/llama-3.3-70b-instruct → llama-3.3, llama3
                    if name.starts_with("llama-") {
                        if let Some((ver, _)) = name[6..].split_once('-') {
                            aliases.push(format!("llama-{}", ver));
                            aliases.push(format!("llama{}", ver.replace(".", "")));
                        }
                    }
                }
                _ => {}
            }
        }

        // Remove duplicates
        aliases.sort();
        aliases.dedup();

        // Generate array literal
        self.generate_string_array(&aliases)
    }

    fn generate_string_array(&self, items: &[String]) -> String {
        items
            .iter()
            .map(|s| format!("\"{}\"", self.escape_string(s)))
            .collect::<Vec<_>>()
            .join(", ")
    }

    fn map_modality(&self, modality: &str) -> &'static str {
        match modality {
            "multimodal" => "Modality::Multimodal",
            "image" => "Modality::Image",
            _ => "Modality::Text",
        }
    }

    fn escape_string(&self, s: &str) -> String {
        s.replace('\\', "\\\\")
            .replace('"', "\\\"")
            .replace('\n', "\\n")
            .replace('\r', "\\r")
            .replace('\t', "\\t")
    }
}

/// Main entry point for build.rs
pub fn generate_catalog_code(models: &[OpenRouterModel]) -> Result<(), Box<dyn std::error::Error>> {
    let generator = CatalogCodeGenerator::new();
    generator.generate(models)
}
