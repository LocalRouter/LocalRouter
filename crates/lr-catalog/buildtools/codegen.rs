// Build-time code generator for catalog
//
// Generates Rust source code with embedded static model data

use crate::buildtools::models::FlattenedModel;
use std::fs;
use std::time::{SystemTime, UNIX_EPOCH};

const OUTPUT_FILE: &str = "catalog/catalog.rs";

pub struct CatalogCodeGenerator {
    output_path: String,
}

impl CatalogCodeGenerator {
    pub fn new() -> Self {
        Self {
            output_path: OUTPUT_FILE.to_string(),
        }
    }

    /// Generate complete catalog.rs file
    pub fn generate(&self, models: &[FlattenedModel]) -> Result<(), Box<dyn std::error::Error>> {
        let mut code = String::new();

        // File header
        code.push_str(&self.generate_header());

        // Imports
        code.push_str(&self.generate_imports());

        // Metadata
        code.push_str(&self.generate_metadata(models.len()));

        // Model array
        code.push_str(&self.generate_models_array(models));

        // Write to file
        fs::write(&self.output_path, code)?;

        println!(
            "cargo:warning=Generated catalog.rs with {} models ({} bytes)",
            models.len(),
            fs::metadata(&self.output_path)?.len()
        );

        Ok(())
    }

    fn generate_header(&self) -> String {
        format!(
            "// Auto-generated model catalog - DO NOT EDIT MANUALLY\n\
             //\n\
             // This file is generated by build.rs from models.dev API data.\n\
             // To regenerate: LOCALROUTER_REBUILD_CATALOG=1 cargo build\n\
             //\n\
             // Generated at: {}\n\
             // Privacy: All data embedded at build time, no runtime network requests\n\n",
            chrono::Utc::now().to_rfc3339()
        )
    }

    fn generate_imports(&self) -> String {
        // Don't generate imports - the file is include!'d into catalog/mod.rs which already has access
        "// Types imported by catalog/mod.rs\n\n".to_string()
    }

    fn generate_metadata(&self, total_models: usize) -> String {
        let now_secs = SystemTime::now()
            .duration_since(UNIX_EPOCH)
            .unwrap()
            .as_secs();

        format!(
            "pub static CATALOG_METADATA: CatalogMetadata = CatalogMetadata {{\n\
             \x20   fetch_timestamp: {},\n\
             \x20   source: \"models.dev\",\n\
             \x20   total_models: {},\n\
             }};\n\n",
            now_secs, total_models
        )
    }

    fn generate_models_array(&self, models: &[FlattenedModel]) -> String {
        let mut code = String::from("pub static CATALOG_MODELS: &[CatalogModel] = &[\n");

        for model in models {
            code.push_str(&self.generate_model_entry(model));
        }

        code.push_str("];\n");
        code
    }

    fn generate_model_entry(&self, model: &FlattenedModel) -> String {
        let aliases = self.generate_aliases(model);
        let modality = self.map_modality(model.model.modality_category());

        format!(
            "    CatalogModel {{\n\
             \x20       id: \"{}\",\n\
             \x20       aliases: &[{}],\n\
             \x20       name: \"{}\",\n\
             \x20       context_length: {},\n\
             \x20       max_output_tokens: {},\n\
             \x20       modality: {},\n\
             \x20       capabilities: CatalogCapabilities {{\n\
             \x20           reasoning: {},\n\
             \x20           tool_call: {},\n\
             \x20           structured_output: {},\n\
             \x20           vision: {},\n\
             \x20       }},\n\
             \x20       pricing: CatalogPricing {{\n\
             \x20           prompt_per_token: {},\n\
             \x20           completion_per_token: {},\n\
             \x20           cache_read_per_token: {},\n\
             \x20           cache_write_per_token: {},\n\
             \x20           currency: \"USD\",\n\
             \x20       }},\n\
             \x20       knowledge_cutoff: {},\n\
             \x20       open_weights: {},\n\
             \x20   }},\n",
            self.escape_string(&model.full_id),
            aliases,
            self.escape_string(&model.model.name),
            model.model.limit.context,
            model
                .model
                .limit
                .output
                .map(|v| format!("Some({})", v))
                .unwrap_or_else(|| "None".to_string()),
            modality,
            model.model.reasoning,
            model.model.tool_call,
            model.model.structured_output,
            model.model.supports_vision(),
            self.format_f64(model.model.prompt_cost_per_token()),
            self.format_f64(model.model.completion_cost_per_token()),
            model
                .model
                .cache_read_cost_per_token()
                .map(|v| format!("Some({})", self.format_f64(v)))
                .unwrap_or_else(|| "None".to_string()),
            model
                .model
                .cache_write_cost_per_token()
                .map(|v| format!("Some({})", self.format_f64(v)))
                .unwrap_or_else(|| "None".to_string()),
            model
                .model
                .knowledge
                .as_ref()
                .map(|v| format!("Some(\"{}\")", self.escape_string(v)))
                .unwrap_or_else(|| "None".to_string()),
            model.model.open_weights,
        )
    }

    fn generate_aliases(&self, model: &FlattenedModel) -> String {
        let mut aliases = Vec::new();

        // Add the model ID (without provider prefix)
        aliases.push(model.model_id.clone());

        // Add provider-specific common variations
        match (model.provider_id.as_str(), model.model_id.as_str()) {
            ("openai", name) if name.starts_with("gpt-") => {
                // gpt-4 → gpt4
                let compact = name.replace('-', "");
                if compact != name {
                    aliases.push(compact);
                }
            }
            ("anthropic", name) if name.contains("claude") => {
                // claude-opus-4-20250514 → claude-opus-4, opus-4
                if let Some(short) = name.split('-').take(3).collect::<Vec<_>>().get(0..3) {
                    aliases.push(short.join("-"));
                }
                if name.contains("opus") {
                    aliases.push("opus".to_string());
                } else if name.contains("sonnet") {
                    aliases.push("sonnet".to_string());
                } else if name.contains("haiku") {
                    aliases.push("haiku".to_string());
                }
            }
            ("google", name) if name.contains("gemini") => {
                // gemini-2.0-flash-exp → gemini-2, gemini-flash
                if let Some(version) = name.strip_prefix("gemini-") {
                    if let Some((ver_num, _)) = version.split_once('-') {
                        aliases.push(format!("gemini-{}", ver_num));
                    }
                }
            }
            ("meta", name) | ("meta-llama", name) if name.contains("llama") => {
                // llama-3.3-70b-instruct → llama-3.3, llama3
                if let Some(stripped) = name.strip_prefix("llama-") {
                    if let Some((ver, _)) = stripped.split_once('-') {
                        aliases.push(format!("llama-{}", ver));
                        aliases.push(format!("llama{}", ver.replace('.', "")));
                    }
                }
            }
            _ => {}
        }

        // Remove duplicates
        aliases.sort();
        aliases.dedup();

        // Generate array literal
        self.generate_string_array(&aliases)
    }

    fn generate_string_array(&self, items: &[String]) -> String {
        items
            .iter()
            .map(|s| format!("\"{}\"", self.escape_string(s)))
            .collect::<Vec<_>>()
            .join(", ")
    }

    fn map_modality(&self, modality: &str) -> &'static str {
        match modality {
            "multimodal" => "Modality::Multimodal",
            "image" => "Modality::Image",
            _ => "Modality::Text",
        }
    }

    fn format_f64(&self, value: f64) -> String {
        // Always format as float literal with decimal point
        if value == 0.0 {
            "0.0".to_string()
        } else if value.fract() == 0.0 {
            format!("{}.0", value)
        } else {
            format!("{}", value)
        }
    }

    fn escape_string(&self, s: &str) -> String {
        s.replace('\\', "\\\\")
            .replace('"', "\\\"")
            .replace('\n', "\\n")
            .replace('\r', "\\r")
            .replace('\t', "\\t")
    }
}

/// Main entry point for build.rs
pub fn generate_catalog_code(models: &[FlattenedModel]) -> Result<(), Box<dyn std::error::Error>> {
    let generator = CatalogCodeGenerator::new();
    generator.generate(models)
}
